From 977680ec20788e8cacb6d5f31d51f368c2967715 Mon Sep 17 00:00:00 2001
From: Nathan Barrett Morrison <nathan.morrison@timesys.com>
Date: Wed, 8 May 2019 12:40:44 -0400
Subject: [PATCH 1/3] Applied 0001-add_wait_block_function_for_MCAPI.patch

---
 include/mcapi_dev_impl.h   |  15 +-
 include/transport_sm.h     |   3 +-
 mcapi.c                    | 168 +++++++++++++---
 mcapi_trans_stub.c         | 492 +++++++++++++++++++++++++++++++++++----------
 trans_impl/tran_impl_dev.c | 126 +++++++++---
 5 files changed, 645 insertions(+), 159 deletions(-)

diff --git a/include/mcapi_dev_impl.h b/include/mcapi_dev_impl.h
index ee540fc..761e473 100644
--- a/include/mcapi_dev_impl.h
+++ b/include/mcapi_dev_impl.h
@@ -11,15 +11,18 @@ int sm_create_session(uint32_t src_ep, uint32_t type);
 int sm_destroy_session(uint32_t src_ep);
 int sm_connect_session(uint32_t dst_ep, uint32_t dst_cpu, uint32_t src_ep);
 int sm_disconnect_session(uint32_t dst_ep, uint32_t src_ep);
-int sm_send_packet(uint32_t session_idx, uint32_t dst_ep,
-		uint32_t dst_cpu, void *buf, uint32_t len);
+int sm_send_packet(uint32_t session_idx, uint32_t dst_ep, uint32_t dst_cpu,
+		void *buf, uint32_t len, int *payload, int blocking);
 int sm_recv_packet(uint32_t session_idx, uint16_t *dst_ep,
-	uint16_t *dst_cpu, void *buf, uint32_t *len);
-int sm_send_scalar(uint32_t session_idx, uint16_t dst_ep,
-		uint16_t dst_cpu, uint32_t scalar0, uint32_t scalar1, uint32_t size);
+		uint16_t *dst_cpu, void *buf, uint32_t *len, int blocking);
+int sm_send_scalar(uint32_t session_idx, uint16_t dst_ep, uint16_t dst_cpu, 
+		uint32_t scalar0, uint32_t scalar1, uint32_t size, int blocking);
 int sm_recv_scalar(uint32_t session_idx, uint16_t *src_ep, uint16_t *src_cpu, uint32_t *scalar0,
-		uint32_t *scalar1, uint32_t *size);
+		uint32_t *scalar1, uint32_t *size, int blocking);
 int sm_get_session_status(uint32_t session_idx, struct sm_session_status *status);
 int sm_get_node_status(uint32_t node, uint32_t *session_mask, uint32_t *session_pending, uint32_t *nfree);
+int sm_wait_nonblocking(uint32_t session_idx, uint32_t dst_ep, uint32_t dst_cpu,
+		void *buf, uint32_t *len, uint32_t type, uint32_t payload, unsigned int timeout, int blocking);
+int sm_get_remote_ep(uint32_t dst_ep, uint32_t dst_cpu, int timeout, int blocking);
 
 #endif
diff --git a/include/transport_sm.h b/include/transport_sm.h
index 83f2620..94cf212 100644
--- a/include/transport_sm.h
+++ b/include/transport_sm.h
@@ -93,7 +93,8 @@ typedef struct {
   mca_boolean_t cancelled;
   mcapi_endpoint_t handle;
   mca_status_t status;
-  mcapi_endpoint_t* ep_endpoint;
+  mcapi_endpoint_t ep_endpoint;
+  uint32_t payload;   /* used only for send_i */
 } mcapi_request_data;
 
 typedef struct  {
diff --git a/mcapi.c b/mcapi.c
index d8734e7..53cc339 100644
--- a/mcapi.c
+++ b/mcapi.c
@@ -575,9 +575,9 @@ mcapi_endpoint_t mcapi_endpoint_get(
   } else if ( ! mcapi_trans_valid_port (port_id)) {
     *mcapi_status = MCAPI_ERR_PORT_INVALID;
   } else {
-    mcapi_trans_endpoint_get (&e,domain_id,node_id,port_id);
+    mcapi_trans_endpoint_get (&e,domain_id,node_id,port_id,mcapi_status,timeout);
   }
-  
+
   return e;
 }
 
@@ -803,9 +803,8 @@ void mcapi_msg_send(
     *mcapi_status = MCAPI_ERR_ENDP_INVALID; /* FIXME (errata A1) */
   } else if (buffer_size > MCAPI_MAX_MSG_SIZE) {
     *mcapi_status = MCAPI_ERR_MSG_LIMIT;
-  } else if ( !mcapi_trans_msg_send (send_endpoint,receive_endpoint,buffer,buffer_size)) {
-    /* assume couldn't get a buffer */
-    *mcapi_status = MCAPI_ERR_MEM_LIMIT;
+  } else {
+	mcapi_trans_msg_send (send_endpoint,receive_endpoint,buffer,buffer_size, mcapi_status);
   } 
 }
 
@@ -938,12 +937,11 @@ void mcapi_msg_recv(
     *mcapi_status = MCAPI_ERR_PARAMETER;
   } else if (!mcapi_trans_valid_endpoint(receive_endpoint)) {
     *mcapi_status = MCAPI_ERR_ENDP_INVALID;
-  } else {
-    mcapi_trans_msg_recv(receive_endpoint,buffer,buffer_size,received_size);
-    if (*received_size > buffer_size) {
-      *received_size = buffer_size;
-      *mcapi_status = MCAPI_ERR_MSG_TRUNCATED;
-    }  
+  } else if (mcapi_trans_msg_recv(receive_endpoint,buffer,buffer_size,received_size, mcapi_status)) {
+	if (*received_size > buffer_size) {
+	  *received_size = buffer_size;
+	  *mcapi_status = MCAPI_ERR_MSG_TRUNCATED;
+	}
   }
 }
 
@@ -993,7 +991,7 @@ mcapi_uint_t mcapi_msg_available(
   if( !mcapi_trans_valid_endpoint(receive_endpoint)) {
     *mcapi_status = MCAPI_ERR_ENDP_INVALID;
   } else {
-    rc = mcapi_trans_msg_available(receive_endpoint);
+    rc = mcapi_trans_msg_available(receive_endpoint, mcapi_status);
   }
   return rc;
 }
@@ -1059,6 +1057,10 @@ void mcapi_pktchan_connect_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
   /* MCAPI_ENO_REQUEST handled at the transport layer */
   
   *mcapi_status = MCAPI_SUCCESS;
@@ -1142,7 +1144,11 @@ void mcapi_pktchan_recv_open_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status) 
 {
-  
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS;   
   if (! request) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -1219,7 +1225,11 @@ void mcapi_pktchan_send_open_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
-  
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS; 
   if (! request) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -1296,6 +1306,11 @@ void mcapi_pktchan_send_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   /* MCAPI_ERR_MEM_LIMIT, MCAPI_ENO_REQUEST and MCAPI_ERR_MEM_LIMIT handled at the transport layer */
   *mcapi_status = MCAPI_SUCCESS; 
   if (!request) {
@@ -1361,7 +1376,11 @@ void mcapi_pktchan_send(
  	MCAPI_IN size_t size, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
-  
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS; 
   if (! mcapi_trans_valid_pktchan_send_handle(send_handle) ) {
     *mcapi_status = MCAPI_ERR_CHAN_INVALID;
@@ -1429,7 +1448,12 @@ void mcapi_pktchan_recv_i(
  	MCAPI_OUT void** buffer, 
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
-{ 
+{
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   /* MCAPI_EPACKLIMIT, MCAPI_ERR_MEM_LIMIT, and MCAPI_ENO_REQUEST are handled at the transport layer */
   *mcapi_status = MCAPI_SUCCESS; 
   if (! request) {
@@ -1495,7 +1519,11 @@ void mcapi_pktchan_recv(
  	MCAPI_OUT size_t* received_size, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
-  
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS;   
   if (! mcapi_trans_valid_buffer_param(buffer)) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -1553,13 +1581,18 @@ mcapi_uint_t mcapi_pktchan_available(
  	MCAPI_IN mcapi_pktchan_recv_hndl_t receive_handle, 
  	MCAPI_OUT mcapi_status_t* mcapi_status) 
 {
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return MCAPI_NULL;
+
   int num = 0;
   
   *mcapi_status = MCAPI_SUCCESS;
   if (! mcapi_trans_valid_pktchan_recv_handle(receive_handle) ) {
     *mcapi_status = MCAPI_ERR_CHAN_INVALID;
   } else {
-    num = mcapi_trans_pktchan_available(receive_handle);
+    num = mcapi_trans_pktchan_available(receive_handle, mcapi_status);
   }
 return num;
 }
@@ -1591,6 +1624,10 @@ void mcapi_pktchan_release(
         /*MCAPI_IN*/ void* buffer,
         MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
 
     *mcapi_status = MCAPI_SUCCESS;
     if (!mcapi_trans_pktchan_free (buffer)) {
@@ -1675,7 +1712,11 @@ void mcapi_pktchan_recv_close_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
-  
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS;  
   if (! request) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -1741,6 +1782,11 @@ void mcapi_pktchan_send_close_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: pktchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS;
   if (!request) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -1816,7 +1862,11 @@ void  mcapi_sclchan_connect_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
-  
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS;
   if (!request) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -1890,6 +1940,11 @@ void mcapi_sclchan_recv_open_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status) 
 {
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS;  
   if (!request) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -1962,7 +2017,11 @@ void mcapi_sclchan_send_open_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
-  
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS;  
   if (!request) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -2014,6 +2073,11 @@ void mcapi_sclchan_send_uint64(
 		MCAPI_IN mcapi_uint64_t dataword,
 		MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+	/* Note: sclchan is not supported now. */
+	*mcapi_status = MCAPI_ERR_GENERAL;
+	printf("%s is not supported.\n", __func__);
+	return;
+
 	/* FIXME: (errata B3) this function needs to check MCAPI_ERR_MEM_LIMIT */
 	*mcapi_status = MCAPI_SUCCESS;
 	if (! mcapi_trans_valid_sclchan_send_handle(send_handle) ) {
@@ -2062,6 +2126,11 @@ void mcapi_sclchan_send_uint32(
 		MCAPI_IN mcapi_uint32_t dataword,
 		MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+	/* Note: sclchan is not supported now. */
+	*mcapi_status = MCAPI_ERR_GENERAL;
+	printf("%s is not supported.\n", __func__);
+	return;
+
 	uint64_t tmp = (uint64_t)dataword;
 	/* FIXME: (errata B3) this function needs to check MCAPI_ERR_MEM_LIMIT */
 	if (! mcapi_trans_valid_status_param(mcapi_status)) {
@@ -2114,6 +2183,11 @@ void mcapi_sclchan_send_uint16(
 		MCAPI_IN mcapi_uint16_t dataword,
 		MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+	/* Note: sclchan is not supported now. */
+	*mcapi_status = MCAPI_ERR_GENERAL;
+	printf("%s is not supported.\n", __func__);
+	return;
+
 	uint64_t tmp = (uint64_t)dataword;
 	/* FIXME: (errata B3) this function needs to check MCAPI_ERR_MEM_LIMIT */
 	*mcapi_status = MCAPI_SUCCESS;
@@ -2159,6 +2233,11 @@ void mcapi_sclchan_send_uint8(
 		MCAPI_IN mcapi_uint8_t dataword,
 		MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+	/* Note: sclchan is not supported now. */
+	*mcapi_status = MCAPI_ERR_GENERAL;
+	printf("%s is not supported.\n", __func__);
+	return;
+
 	uint64_t tmp = (uint64_t)dataword;
 	/* FIXME: (errata B3) this function needs to check MCAPI_ERR_MEM_LIMIT */
 	*mcapi_status = MCAPI_SUCCESS;
@@ -2205,6 +2284,11 @@ mcapi_uint64_t mcapi_sclchan_recv_uint64(
  	MCAPI_IN mcapi_sclchan_recv_hndl_t receive_handle, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return 0;
+
   uint64_t dataword = 0;
   uint32_t exp_size = 8; 
   
@@ -2253,6 +2337,11 @@ mcapi_uint32_t mcapi_sclchan_recv_uint32(
  	MCAPI_IN mcapi_sclchan_recv_hndl_t receive_handle, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return 0;
+
   uint64_t dataword = 0;
   uint32_t exp_size = 4; 
   
@@ -2302,6 +2391,10 @@ mcapi_uint16_t mcapi_sclchan_recv_uint16(
  	MCAPI_IN mcapi_sclchan_recv_hndl_t receive_handle, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return 0;
 
   uint64_t dataword = 0;
   uint32_t exp_size = 2; 
@@ -2352,6 +2445,11 @@ mcapi_uint8_t mcapi_sclchan_recv_uint8(
  	MCAPI_IN mcapi_sclchan_recv_hndl_t receive_handle, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return 0;
+
   uint64_t dataword = 0;
   uint32_t exp_size = 1; 
   
@@ -2401,13 +2499,18 @@ mcapi_uint_t mcapi_sclchan_available (
  	MCAPI_IN mcapi_sclchan_recv_hndl_t receive_handle, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return MCAPI_NULL;
+
   int num = 0;
   
   *mcapi_status = MCAPI_SUCCESS; 
   if (! mcapi_trans_valid_sclchan_recv_handle(receive_handle) ) {
     *mcapi_status = MCAPI_ERR_CHAN_INVALID;
   } else {
-    num = mcapi_trans_sclchan_available_i(receive_handle);
+    num = mcapi_trans_sclchan_available_i(receive_handle, mcapi_status);
   }
   return num;
 }
@@ -2457,6 +2560,10 @@ void mcapi_sclchan_recv_close_i(
 	MCAPI_OUT mcapi_request_t* request, 
 	MCAPI_OUT mcapi_status_t* mcapi_status) 
 {
+	/* Note: sclchan is not supported now. */
+	*mcapi_status = MCAPI_ERR_GENERAL;
+	printf("%s is not supported.\n", __func__);
+	return;
 
     *mcapi_status = MCAPI_SUCCESS;
     if (!request) {
@@ -2522,6 +2629,11 @@ void mcapi_sclchan_send_close_i(
  	MCAPI_OUT mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: sclchan is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS;   
   if (!request) {
     *mcapi_status = MCAPI_ERR_PARAMETER;
@@ -2574,7 +2686,7 @@ mcapi_boolean_t mcapi_test(
 		MCAPI_OUT size_t* size,
 		MCAPI_OUT mcapi_status_t* mcapi_status)
 {
-	mcapi_boolean_t rc = MCAPI_FALSE;
+  mcapi_boolean_t rc = MCAPI_FALSE;
   *mcapi_status = MCAPI_SUCCESS;
  
   if (! mcapi_trans_valid_size_param(size)) {
@@ -2713,6 +2825,11 @@ MCAPI_ERR_PARAMETER	Incorrect number (if  =  0), requests or size parameter.
                                      MCAPI_IN mcapi_timeout_t timeout,
                                      MCAPI_OUT mcapi_status_t* mcapi_status) 
 {
+  /* Note: this API is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return MCAPI_RETURN_VALUE_INVALID;
+
   unsigned int rc = MCAPI_RETURN_VALUE_INVALID; 
   
   *mcapi_status = MCAPI_SUCCESS; 
@@ -2755,6 +2872,11 @@ void mcapi_cancel(
  	MCAPI_IN mcapi_request_t* request, 
  	MCAPI_OUT mcapi_status_t* mcapi_status)
 {
+  /* Note: this API is not supported now. */
+  *mcapi_status = MCAPI_ERR_GENERAL;
+  printf("%s is not supported.\n", __func__);
+  return;
+
   *mcapi_status = MCAPI_SUCCESS; 
     if (!mcapi_trans_valid_request_handle(request)) {
     *mcapi_status = MCAPI_ERR_REQUEST_INVALID;
diff --git a/mcapi_trans_stub.c b/mcapi_trans_stub.c
index 8a3ecef..79293a7 100644
--- a/mcapi_trans_stub.c
+++ b/mcapi_trans_stub.c
@@ -68,7 +68,7 @@ mcapi_node_t mcapi_node_num = 0;
 mcapi_domain_t mcapi_domain_id = 0;
 
 /* the debug level */
-int mcapi_debug = 7;
+int mcapi_debug = 0;
 /* debug printing */
 /* Inline this (and define in header) so that it can be compiled out if WITH_DEBUG is 0 */
 inline void mcapi_dprintf(int level,const char *format, ...) {
@@ -84,6 +84,7 @@ inline void mcapi_dprintf(int level,const char *format, ...) {
 	}
 }
 mcapi_endpoint_t mcapi_icc_index;
+mcapi_boolean_t mcapi_trans_valid_request_handle (mcapi_request_t* request);
 
 /* semaphore management */
 int transport_sm_create_semaphore(uint32_t semkey) {
@@ -396,8 +397,9 @@ mcapi_boolean_t mcapi_trans_remove_request(int r) {
 
 	mcapi_boolean_t rc = MCAPI_FALSE;
 	indexed_array_header *header = &c_db->request_reserves_header;
-
+	assert(mcapi_trans_valid_request_handle(&r));
 	if (header->curr_count < header->max_count) {
+		c_db->requests[r].valid = MCAPI_FALSE;
 		header->array[r].next_index = header->empty_head_index;
 		header->empty_head_index = r;
 		header->curr_count--;
@@ -493,26 +495,28 @@ mcapi_boolean_t mcapi_trans_decode_handle_internal (uint32_t handle, uint16_t *d
 	return rc;
 }
 
-void setup_request_internal (mcapi_endpoint_t send, mcapi_endpoint_t recv,
-		mcapi_request_t* request, size_t size, mcapi_request_type type)
+void setup_request_internal (mcapi_endpoint_t local_ep, mcapi_endpoint_t remote_ep,
+	mcapi_request_t* request, char *buffer, size_t size,
+	uint32_t payload, mcapi_request_type type)
 {
-#if 0
-	if (!request)
+	if (request == NULL)
 		return;
-
-	request->send_endpoint = send;
-	request->recv_endpoint = recv;
-	request->valid = MCAPI_TRUE;
-	request->size = size;
-	request->cancelled = MCAPI_FALSE;
-	request->type = type;
-#endif
+	mcapi_database *mcapi_db = c_db;
+	int id = *request;
+	mcapi_db->requests[id].ep_endpoint = remote_ep;
+	mcapi_db->requests[id].handle= local_ep;
+	mcapi_db->requests[id].valid = MCAPI_TRUE;
+	mcapi_db->requests[id].size = size;
+	mcapi_db->requests[id].cancelled = MCAPI_FALSE;
+	mcapi_db->requests[id].type = type;
+	mcapi_db->requests[id].buffer = buffer;
+	mcapi_db->requests[id].payload = payload;
 }
 
 mcapi_boolean_t mcapi_trans_decode_request_handle(mcapi_request_t* request,uint16_t* r) 
 {
 	*r = *request;
-	if ((*r < MCAPI_MAX_REQUESTS) && (*request & 0x80000000)) {
+	if (*r < MCAPI_MAX_REQUESTS && c_db->requests[*r].valid == MCAPI_TRUE) {
 		return MCAPI_TRUE;
 	}
 	return MCAPI_FALSE;
@@ -551,10 +555,9 @@ mcapi_boolean_t mcapi_trans_valid_endpoint (mcapi_endpoint_t endpoint)
 		}
 
 		rc = c_db->domains[domain_index].nodes[0].node_d.endpoints[index].valid;
+		mcapi_dprintf(3,"mcapi_trans_valid_endpoint endpoint=0x%llx (database indices: n=%d,e=%d) rc=%d\n",(unsigned long long)endpoint,n,e,rc);
 	}
 
-	mcapi_dprintf(3,"mcapi_trans_valid_endpoint endpoint=0x%llx (database indices: n=%d,e=%d) rc=%d\n",(unsigned long long)endpoint,n,e,rc);
-
 	return rc;
 }
 
@@ -854,6 +857,7 @@ mcapi_boolean_t mcapi_trans_initialize_()
 
 	}
 	transport_sm_unlock_semaphore(sem_id);
+	mcapi_trans_init_request_indexed_array();
 	mcapi_dprintf(1, "%s %d\n", __func__, __LINE__);
 	return rc;
 }
@@ -939,24 +943,79 @@ mcapi_boolean_t mcapi_trans_get_endpoint_internal (mcapi_endpoint_t *e, mcapi_ui
 
 
 /* non-blocking get endpoint for the given <node_num,port_num> and set endpoint parameter to it's handle */
-void mcapi_trans_endpoint_get_i(  mcapi_endpoint_t* endpoint, mcapi_uint_t node_num, mcapi_uint_t port_num,mcapi_request_t* request,mcapi_status_t* mcapi_status)
+void mcapi_trans_endpoint_get_i(mcapi_endpoint_t* endpoint, mcapi_domain_t domain_num, mcapi_uint_t node_num, mcapi_uint_t port_num,mcapi_request_t* request,mcapi_status_t* mcapi_status)
 {
-	if (mcapi_trans_get_endpoint_internal(endpoint, node_num, port_num))
-		*mcapi_status = MCAPI_SUCCESS;
-	else
-		*mcapi_status = MCAPI_ERR_PARAMETER;
+	int ret;
+	int id;
+	int index;
+	mcapi_database* mcapi_db = c_db;
+	index = mcapi_trans_get_port_index(node_num, port_num);
+	/* local endpoint */
+	if (index != MCAPI_MAX_ENDPOINTS) {
+		if (mcapi_trans_get_endpoint_internal(endpoint, node_num, port_num))
+			*mcapi_status = MCAPI_SUCCESS;
+		else
+			*mcapi_status = MCAPI_ERR_PARAMETER;
+		return;
+	}
+	if (!mcapi_trans_reserve_request(&id)) {
+		*mcapi_status = MCAPI_ERR_REQUEST_LIMIT;
+		return;
+	}
+	*request = id;
+	mcapi_dprintf(1,"node_num:%d, port_num:%d, id:%d\n", node_num, port_num, id);
+
+	ret = sm_get_remote_ep(port_num, node_num, 0, 0);
+	if (ret) {
+		if (errno == EAGAIN) {
+			mcapi_db->requests[*request].completed = MCAPI_FALSE;
+			*mcapi_status = MCAPI_PENDING;
+		} else {
+			mcapi_db->requests[*request].completed = MCAPI_FALSE;
+			*mcapi_status = MCAPI_ERR_TRANSMISSION;
+		}
+	} else {
+		mcapi_db->requests[*request].completed = MCAPI_TRUE;
+		if (mcapi_trans_get_endpoint_internal(endpoint, node_num, port_num))
+			*mcapi_status = MCAPI_SUCCESS;
+		else
+			*mcapi_status = MCAPI_ERR_PARAMETER;
+	}
+	mcapi_db->requests[*request].ep_node_num = node_num;
+	mcapi_db->requests[*request].ep_port_num = port_num;
+	mcapi_db->requests[*request].ep_domain_num = domain_num;
+	setup_request_internal(0, 0, request, (char *)endpoint, 0, 0, GET_ENDPT);
 }
 
 /* blocking get endpoint for the given <node_num,port_num> and return it's handle */
-mcapi_boolean_t mcapi_trans_endpoint_get(mcapi_endpoint_t *endpoint,mcapi_domain_t domain_num, mcapi_node_t node_num, mcapi_port_t port_num)
+mcapi_boolean_t mcapi_trans_endpoint_get(mcapi_endpoint_t *endpoint,mcapi_domain_t domain_num, mcapi_node_t node_num, mcapi_port_t port_num, mcapi_status_t* mcapi_status, int timeout)
 {
-	mcapi_status_t mcapi_status;
-	mcapi_request_t request;
-	mcapi_trans_endpoint_get_i(endpoint, node_num, port_num, &request, &mcapi_status);
-	if (mcapi_status == MCAPI_SUCCESS)
+	int ret;
+	int index;
+
+	index = mcapi_trans_get_port_index(node_num, port_num);
+	/* local endpoint */
+	if (index != MCAPI_MAX_ENDPOINTS) {
+		if (mcapi_trans_get_endpoint_internal(endpoint, node_num, port_num))
+			*mcapi_status = MCAPI_SUCCESS;
+		else
+			*mcapi_status = MCAPI_ERR_PARAMETER;
 		return MCAPI_TRUE;
-	else
+	}
+	ret = sm_get_remote_ep(port_num, node_num, timeout, 1);
+	if (ret) {
+		if (errno == ETIMEDOUT)
+			*mcapi_status = MCAPI_TIMEOUT;
+		else
+			*mcapi_status = MCAPI_ERR_GENERAL;
 		return MCAPI_FALSE;
+	} else {
+		if (mcapi_trans_get_endpoint_internal(endpoint, node_num, port_num))
+			*mcapi_status = MCAPI_SUCCESS;
+		else
+			*mcapi_status = MCAPI_ERR_PARAMETER;
+	    return MCAPI_TRUE;
+	}
 }
 
 mcapi_boolean_t mcapi_trans_endpoint_exists(mcapi_uint_t port_num)
@@ -1089,35 +1148,72 @@ void mcapi_trans_msg_send_i( mcapi_endpoint_t  send_endpoint, mcapi_endpoint_t
 	uint16_t rd,rn,re;
 	int ret;
 	int index;
+	int id;
+	uint32_t payload;
+	mcapi_database* mcapi_db = c_db;
+	
+	if (!mcapi_trans_reserve_request(&id)) {
+		*mcapi_status = MCAPI_ERR_REQUEST_LIMIT;
+		return;	
+	}
+	*request = id;
 
 	assert(mcapi_trans_decode_handle_internal(send_endpoint,&sd,&sn,&se));
 	assert(mcapi_trans_decode_handle_internal(receive_endpoint,&rd,&rn,&re));
-
 	index = mcapi_trans_get_port_index(sn, se);
 
-	mcapi_dprintf(1,"index %d, se %d, sn %d\n", index, se, sn);
+	mcapi_dprintf(1,"index %d, se %d, sn %d req id:%d \n", index, se, sn, id);
 
 	if (index >= MCAPI_MAX_ENDPOINTS) {
-		*mcapi_status = MCAPI_FALSE;
+		*mcapi_status = MCAPI_ERR_ENDP_INVALID;
 		return;
 	}
 
-	mcapi_dprintf(1,"index %d, re %d, rn %d\n", index, re, rn);
-	ret = sm_send_packet(index, re, rn, buffer, buffer_size);
+	ret = sm_send_packet(index, re, rn, buffer, buffer_size, &payload, 0);
 	if (ret) {
-		mcapi_dprintf(1,"send failed\n");
-		*mcapi_status = ret;
-	} else
+		if (errno == EAGAIN) {
+			mcapi_db->requests[*request].completed = MCAPI_FALSE;
+			*mcapi_status = MCAPI_PENDING;
+		} else {
+			mcapi_db->requests[*request].completed = MCAPI_FALSE;
+			*mcapi_status = MCAPI_ERR_TRANSMISSION;
+		}
+	} else {
+		mcapi_db->requests[*request].completed = MCAPI_TRUE;
 		*mcapi_status = MCAPI_SUCCESS;
+	}
 
-	setup_request_internal(send_endpoint, receive_endpoint, request, buffer_size, SEND);
+	setup_request_internal(send_endpoint, receive_endpoint, request, NULL, buffer_size, payload, SEND);
 }
 
+mcapi_boolean_t mcapi_trans_msg_send( mcapi_endpoint_t  send_endpoint, mcapi_endpoint_t  receive_endpoint, char* buffer, size_t buffer_size, mcapi_status_t* mcapi_status)
+{
+	uint16_t sd,sn,se;
+	uint16_t rd,rn,re;
+	int ret;
+	int index;
 
+	assert(mcapi_trans_decode_handle_internal(send_endpoint,&sd,&sn,&se));
+	assert(mcapi_trans_decode_handle_internal(receive_endpoint,&rd,&rn,&re));
 
-mcapi_boolean_t mcapi_trans_msg_send( mcapi_endpoint_t  send_endpoint, mcapi_endpoint_t  receive_endpoint, char* buffer, size_t buffer_size)
-{
-  return MCAPI_FALSE;
+	index = mcapi_trans_get_port_index(sn, se);
+
+	if (index >= MCAPI_MAX_ENDPOINTS) {
+		*mcapi_status = MCAPI_ERR_ENDP_INVALID;
+		return MCAPI_FALSE;
+	}
+
+	ret = sm_send_packet(index, re, rn, buffer, buffer_size, NULL, 1);
+	if (ret) {
+		if (errno == ETIMEDOUT)
+			*mcapi_status = MCAPI_TIMEOUT;
+		else
+			*mcapi_status = MCAPI_ERR_GENERAL;
+		return MCAPI_FALSE;
+	} else {
+		*mcapi_status = MCAPI_SUCCESS;
+	    return MCAPI_TRUE;
+	}
 }
 
 
@@ -1128,42 +1224,80 @@ void mcapi_trans_msg_recv_i( mcapi_endpoint_t  receive_endpoint,  char* buffer,
 	uint16_t rd,rn,re;
 	int ret;
 	int index;
+	int id;
 	uint32_t len;
 	mcapi_endpoint_t  send_endpoint;
+	mcapi_database* mcapi_db = c_db;
 
+	if (!mcapi_trans_reserve_request(&id)) {
+		*mcapi_status = MCAPI_ERR_REQUEST_LIMIT;
+		return;	
+	}
+	*request = id;
 	assert(mcapi_trans_decode_handle_internal(receive_endpoint,&rd,&rn,&re));
 
 	index = mcapi_trans_get_port_index(rn, re);
 
 	if (index >= MCAPI_MAX_ENDPOINTS) {
-		*mcapi_status = MCAPI_FALSE;
+		*mcapi_status = MCAPI_ERR_ENDP_INVALID;
 		return;
 	}
-
-	ret = sm_recv_packet(index, &se, &sn, buffer, &len);
-	if (ret < 0) {
-		mcapi_dprintf(1,"recv failed\n");
-		*mcapi_status = MCAPI_FALSE;
-		return;
+	len = buffer_size;
+	ret = sm_recv_packet(index, &se, &sn, buffer, &len, 0);
+	if(ret) {
+		if(errno == EAGAIN) {
+			mcapi_db->requests[*request].completed = MCAPI_FALSE;
+			*mcapi_status = MCAPI_PENDING;
+		} else {
+			mcapi_db->requests[*request].completed = MCAPI_FALSE;
+			*mcapi_status = MCAPI_ERR_TRANSMISSION;
+		}
 	} else {
-	mcapi_dprintf(1,"index %d, se %d, sn %d\n", index, se, sn);
+		mcapi_db->requests[*request].completed = MCAPI_TRUE;
 		*mcapi_status = MCAPI_SUCCESS;
 	}
-
+	mcapi_db->requests[*request].size = len;
 	send_endpoint = mcapi_trans_encode_handle_internal(0,sn,se);
 
-	setup_request_internal(send_endpoint, receive_endpoint, request, len, RECV);
+	setup_request_internal(receive_endpoint, send_endpoint, request, buffer, len, 0, RECV);
 }
 
 
 
-mcapi_boolean_t mcapi_trans_msg_recv( mcapi_endpoint_t  receive_endpoint,  char* buffer, size_t buffer_size, size_t* received_size)
+mcapi_boolean_t mcapi_trans_msg_recv( mcapi_endpoint_t  receive_endpoint,  char* buffer, size_t buffer_size, size_t* received_size, mcapi_status_t* mcapi_status)
 {
-  return MCAPI_FALSE;
+	uint16_t sn,se;
+	uint16_t rd,rn,re;
+	int ret;
+	int index;
+	uint32_t len;
+	mcapi_endpoint_t  send_endpoint;
+
+	assert(mcapi_trans_decode_handle_internal(receive_endpoint,&rd,&rn,&re));
+
+	index = mcapi_trans_get_port_index(rn, re);
+
+	if (index >= MCAPI_MAX_ENDPOINTS) {
+		*mcapi_status = MCAPI_ERR_ENDP_INVALID;
+		return MCAPI_FALSE;
+	}
+	len = buffer_size;
+	ret = sm_recv_packet(index, &se, &sn, buffer, &len, 1);
+	if (ret) {
+		if (errno == ETIMEDOUT)
+			*mcapi_status = MCAPI_TIMEOUT;
+		else
+			*mcapi_status = MCAPI_ERR_GENERAL;
+		return MCAPI_FALSE;
+	} else {
+		*mcapi_status = MCAPI_SUCCESS;
+		*received_size = len;
+		return MCAPI_TRUE;
+	}
 }
 
 
-mcapi_uint_t mcapi_trans_msg_available( mcapi_endpoint_t receive_endpoint)
+mcapi_uint_t mcapi_trans_msg_available( mcapi_endpoint_t receive_endpoint, mcapi_status_t* mcapi_status)
 {
 	uint16_t rd,rn,re;
 	int index;
@@ -1175,13 +1309,17 @@ mcapi_uint_t mcapi_trans_msg_available( mcapi_endpoint_t receive_endpoint)
 	index = mcapi_trans_get_port_index(rn, re);
 
 	if (index >= MCAPI_MAX_ENDPOINTS) {
-		return -EINVAL;
+		*mcapi_status = MCAPI_ERR_ENDP_INVALID;
+		return MCAPI_NULL;
 	}
 
 	ret = sm_get_session_status(index, &status);
-	if (ret)
-		return ret;
+	if (ret) {
+		*mcapi_status = MCAPI_ERR_GENERAL;
+		return MCAPI_NULL;
+	}
 	mcapi_dprintf(1, "%s avail = %d\n", __func__, status.n_avail);
+	*mcapi_status = MCAPI_SUCCESS;
 	return status.n_avail;
 }
 
@@ -1278,26 +1416,47 @@ void  mcapi_trans_pktchan_send_i( mcapi_pktchan_send_hndl_t send_handle, void* b
 
 	index = mcapi_trans_get_port_index(sn, se);
 	if (index >= MCAPI_MAX_ENDPOINTS) {
-		*mcapi_status = MCAPI_FALSE;
+		*mcapi_status = MCAPI_ERR_CHAN_INVALID;
 		return;
 	}
 
 	assert(mcapi_trans_decode_handle_internal(c_db->domains[0].nodes[0].node_d.endpoints[index].recv_queue.recv_endpt,&rd,&rn,&re));
 	mcapi_dprintf(1,"index %d, re %d, rn %d\n", index, re, rn);
-	ret = sm_send_packet(index, re, rn, buffer, size);
+	ret = sm_send_packet(index, re, rn, buffer, size, NULL, 0);
 	if (ret) {
 		mcapi_dprintf(1,"send failed\n");
-		*mcapi_status = ret;
+		*mcapi_status = MCAPI_ERR_TRANSMISSION;
 	} else
 		*mcapi_status = MCAPI_SUCCESS;
 
-	setup_request_internal(send_handle, c_db->domains[0].nodes[0].node_d.endpoints[index].recv_queue.recv_endpt, request, size, SEND);
+	setup_request_internal(send_handle, c_db->domains[0].nodes[0].node_d.endpoints[index].recv_queue.recv_endpt, request, NULL, size, 0, SEND);
 }
 
 
 mcapi_boolean_t  mcapi_trans_pktchan_send( mcapi_pktchan_send_hndl_t send_handle, void* buffer, size_t size)
 {
-  return MCAPI_FALSE;
+	uint16_t sd,sn,se;
+	uint16_t rd,rn,re;
+	int ret;
+	int index;
+
+	mcapi_dprintf(1,"%s send_handle %d\n", __func__,send_handle);
+	assert(mcapi_trans_decode_handle_internal(send_handle,&sd,&sn,&se));
+
+	index = mcapi_trans_get_port_index(sn, se);
+	if (index >= MCAPI_MAX_ENDPOINTS)
+		return MCAPI_FALSE;
+
+	assert(mcapi_trans_decode_handle_internal(c_db->domains[0].nodes[0].node_d.endpoints[index].recv_queue.recv_endpt,&rd,&rn,&re));
+	mcapi_dprintf(1,"index %d, re %d, rn %d\n", index, re, rn);
+	ret = sm_send_packet(index, re, rn, buffer, size, NULL, 1);
+	if (ret) {
+		mcapi_dprintf(1,"send failed\n");
+		ret = MCAPI_FALSE;
+	} else
+		ret = MCAPI_SUCCESS;
+
+	return ret;
 }
 
 
@@ -1316,20 +1475,19 @@ void mcapi_trans_pktchan_recv_i( mcapi_pktchan_recv_hndl_t receive_handle,  void
 	assert(mcapi_trans_decode_handle_internal(receive_handle,&rd,&rn,&re));
 	index = mcapi_trans_get_port_index(rn, re);
 	if (index >= MCAPI_MAX_ENDPOINTS) {
-		*mcapi_status = MCAPI_FALSE;
+		*mcapi_status = MCAPI_ERR_CHAN_INVALID;
 		return;
 	}
-
 	if (!mcapi_trans_reserve_request(&i)) {
 		*mcapi_status = MCAPI_ERR_REQUEST_LIMIT;
 		return;
 	}
 	db_buff = &c_db->buffers[i];
 
-	ret = sm_recv_packet(index,&se, &sn, db_buff->buff, &len);
+	ret = sm_recv_packet(index,&se, &sn, db_buff->buff, &len, 0);
 	if (ret < 0) {
 		mcapi_dprintf(1,"recv failed\n");
-		*mcapi_status = MCAPI_FALSE;
+		*mcapi_status = MCAPI_ERR_TRANSMISSION;
 		return;
 	}
 	mcapi_dprintf(1,"index %d, se %d, sn %d\n", index, se, sn);
@@ -1338,19 +1496,50 @@ void mcapi_trans_pktchan_recv_i( mcapi_pktchan_recv_hndl_t receive_handle,  void
 	*mcapi_status = MCAPI_SUCCESS;
 
 	send_endpoint = mcapi_trans_encode_handle_internal(0,sn,se);
-	setup_request_internal(send_endpoint, receive_handle, request, len, RECV);
+	setup_request_internal(send_endpoint, receive_handle, request, db_buff->buff, len, 0, RECV);
 }
 
 
 mcapi_boolean_t mcapi_trans_pktchan_recv( mcapi_pktchan_recv_hndl_t receive_handle, void** buffer, size_t* received_size)
 {
-  return MCAPI_FALSE;
+	uint16_t sn,se;
+	uint16_t rd,rn,re;
+	int ret;
+	int index;
+	uint32_t len;
+	int i;
+	mcapi_endpoint_t send_endpoint;
+	buffer_entry* db_buff = NULL;
+
+	assert(mcapi_trans_decode_handle_internal(receive_handle,&rd,&rn,&re));
+	index = mcapi_trans_get_port_index(rn, re);
+	if (index >= MCAPI_MAX_ENDPOINTS)
+		return MCAPI_FALSE;
+
+	if (!mcapi_trans_reserve_request(&i))
+		return MCAPI_ERR_REQUEST_LIMIT;
+
+	db_buff = &c_db->buffers[i];
+
+	ret = sm_recv_packet(index,&se, &sn, db_buff->buff, &len, 1);
+	if (ret < 0) {
+		mcapi_dprintf(1,"recv failed\n");
+		return MCAPI_FALSE;
+	}
+	mcapi_dprintf(1,"index %d, se %d, sn %d\n", index, se, sn);
+
+	*buffer = db_buff->buff;
+	ret = MCAPI_SUCCESS;
+
+	send_endpoint = mcapi_trans_encode_handle_internal(0,sn,se);
+	return ret;
+
 }
 
-mcapi_uint_t mcapi_trans_pktchan_available( mcapi_pktchan_recv_hndl_t   receive_handle)
+mcapi_uint_t mcapi_trans_pktchan_available( mcapi_pktchan_recv_hndl_t receive_handle, mcapi_status_t* mcapi_status)
 {
 	mcapi_uint_t avail;
-	avail = mcapi_trans_msg_available(receive_handle);
+	avail = mcapi_trans_msg_available(receive_handle, mcapi_status);
 	return avail;
 }
 
@@ -1502,10 +1691,10 @@ void mcapi_trans_sclchan_send_open_i( mcapi_sclchan_send_hndl_t* send_handle, mc
 
 
 
-mcapi_uint_t mcapi_trans_sclchan_available_i( mcapi_sclchan_recv_hndl_t receive_handle)
+mcapi_uint_t mcapi_trans_sclchan_available_i( mcapi_sclchan_recv_hndl_t receive_handle, mcapi_status_t* mcapi_status)
 {
 	mcapi_uint_t avail;
-	avail = mcapi_trans_msg_available(receive_handle);
+	avail = mcapi_trans_msg_available(receive_handle, mcapi_status);
 	return avail;
 }
 
@@ -1592,7 +1781,7 @@ mcapi_boolean_t mcapi_trans_sclchan_send( mcapi_sclchan_send_hndl_t send_handle,
 	}
 
 	mcapi_dprintf(1,"size %d\n", size);
-	ret = sm_send_scalar(index, re, rn, scalar0, scalar1, size);
+	ret = sm_send_scalar(index, re, rn, scalar0, scalar1, size, 1);
 	if (ret)
 		mcapi_dprintf(1,"send failed %x\n", ret);
 	return MCAPI_TRUE;
@@ -1615,7 +1804,7 @@ mcapi_boolean_t mcapi_trans_sclchan_recv( mcapi_sclchan_recv_hndl_t receive_hand
 		return MCAPI_FALSE;
 	}
 
-	ret = sm_recv_scalar(index, &se, &sn, &scalar0, &scalar1, &type);
+	ret = sm_recv_scalar(index, &se, &sn, &scalar0, &scalar1, &type, 1);
 	if (ret != 1) {
 		mcapi_dprintf(1,"recv failed\n");
 		return MCAPI_FALSE;
@@ -1646,60 +1835,155 @@ mcapi_boolean_t mcapi_trans_sclchan_recv( mcapi_sclchan_recv_hndl_t receive_hand
 mcapi_boolean_t mcapi_trans_test_i( mcapi_request_t* request, size_t* size,mcapi_status_t* mcapi_status)
 {
 	mcapi_boolean_t rc;
-	rc = MCAPI_FALSE;
-	uint16_t rn,re;
+	uint16_t sd,sn,se;
+	uint16_t rd,rn,re;
 	int index;
 	int ret;
+	int id;
 	mcapi_uint_t avail = 0;
 	mcapi_uint_t uncomplete = 0;
 	struct sm_session_status status;
+	mcapi_database *mcapi_db = c_db;
+	assert(mcapi_trans_valid_request_handle(request));
+	id = *request;
+	*mcapi_status = 0;
+	rc = MCAPI_FALSE;
 
-#if 0
-	if (request->valid == MCAPI_FALSE) {
+	if (mcapi_db->requests[id].valid == MCAPI_FALSE) {
 		*mcapi_status = MCAPI_ERR_REQUEST_INVALID;
 		rc = MCAPI_FALSE;
-	} else if (request->cancelled) {
+	} else if (mcapi_db->requests[id].cancelled) {
 		*mcapi_status = MCAPI_ERR_REQUEST_CANCELLED;
 		rc = MCAPI_FALSE;
-	} else if (!(request->completed)) {
+	} else if ((mcapi_db->requests[id].completed)) {
+		*mcapi_status = MCAPI_SUCCESS;
+		if (size)
+			*size = mcapi_db->requests[id].size;
+		rc = MCAPI_TRUE;
+	} else if (!(mcapi_db->requests[id].completed)) {
 		/* try to complete the request */
 		/*  receives to an empty channel or get_endpt for an endpt that
 		    doesn't yet exist are the only two types of non-blocking functions
 		    that don't complete immediately for this implementation */
-		assert(mcapi_trans_decode_handle_internal(request->handle,&rn,&re));
-		index = mcapi_trans_get_port_index(rn, re);
-		if (index >= MCAPI_MAX_ENDPOINTS) {
-			*mcapi_status = MCAPI_FALSE;
-			return MCAPI_FALSE;
+		if (mcapi_db->requests[id].type != GET_ENDPT) {
+			assert(mcapi_trans_decode_handle_internal(mcapi_db->requests[id].handle,&sd,&sn,&se));
+			assert(mcapi_trans_decode_handle_internal(mcapi_db->requests[id].ep_endpoint,&rd,&rn,&re));
+			index = mcapi_trans_get_port_index(sn, se);
+			if (index >= MCAPI_MAX_ENDPOINTS) {
+				*mcapi_status = MCAPI_ERR_NODE_NOTINIT;
+				return MCAPI_FALSE;
+			}
+		} else {
+			index = 0;
+			re = mcapi_db->requests[id].ep_port_num;
+			rn = mcapi_db->requests[id].ep_node_num;
 		}
-
-		ret = sm_get_session_status(index, &status);
-		if (ret)
-			return ret;
-
-		switch (request->type) {
-			case (RECV) :
-				if (status.n_avail)
-					rc = MCAPI_TRUE;
-			case (SEND) :
-				if (!status.n_uncompleted)
+		if (size)
+			*size = mcapi_db->requests[id].size;
+		rc = sm_wait_nonblocking(index, re, rn, mcapi_db->requests[id].buffer,
+					size, mcapi_db->requests[id].type, mcapi_db->requests[id].payload, 0, 0);
+		if (rc) {
+			if (errno == EAGAIN)
+				*mcapi_status = MCAPI_PENDING;
+			else
+				*mcapi_status = MCAPI_ERR_GENERAL;
+			mcapi_db->requests[id].completed = MCAPI_FALSE;
+			rc = MCAPI_FALSE;
+		} else {
+			if (mcapi_db->requests[id].type == GET_ENDPT) {
+				if (mcapi_trans_get_endpoint_internal(
+						(mcapi_endpoint_t *)mcapi_db->requests[id].buffer,
+						mcapi_db->requests[id].ep_node_num,
+						mcapi_db->requests[id].ep_port_num)) {
+					mcapi_db->requests[id].completed = MCAPI_TRUE;
+					*mcapi_status = MCAPI_SUCCESS;
 					rc = MCAPI_TRUE;
-			case (GET_ENDPT) :
-			default:
-				assert(0);
-				break;
-		};
+				} else {
+					mcapi_db->requests[id].completed = MCAPI_TRUE;
+					*mcapi_status = MCAPI_ERR_PARAMETER;
+					rc = MCAPI_FALSE;
+				}
+			} else {
+				mcapi_db->requests[id].completed = MCAPI_TRUE;
+				*mcapi_status = MCAPI_SUCCESS;
+				if (size)
+					mcapi_db->requests[id].size = *size;
+				rc = MCAPI_TRUE;
+			}
+		}
 	}
-#endif
 	return rc;
 }
 
-
-
 mcapi_boolean_t mcapi_trans_wait( mcapi_request_t* request, size_t* size,
 			mcapi_status_t* mcapi_status,  mcapi_timeout_t timeout)
 {
-  return MCAPI_FALSE;
+	uint16_t sd,sn,se;
+	uint16_t rd,rn,re;
+	int index;
+	int id;
+	mcapi_timeout_t time = 0;
+	mcapi_boolean_t rc;
+	mcapi_database *mcapi_db = c_db;
+
+	assert(mcapi_trans_valid_request_handle(request));
+	id = *request;
+	if (mcapi_db->requests[id].type != GET_ENDPT) {
+		assert(mcapi_trans_decode_handle_internal(mcapi_db->requests[id].handle,&sd,&sn,&se));
+		assert(mcapi_trans_decode_handle_internal(mcapi_db->requests[id].ep_endpoint,&rd,&rn,&re));
+		index = mcapi_trans_get_port_index(sn, se);
+		if (index >= MCAPI_MAX_ENDPOINTS) {
+			*mcapi_status = MCAPI_ERR_NODE_NOTINIT;
+			return MCAPI_FALSE;
+		}
+	} else {
+		index = 0;
+		re = mcapi_db->requests[id].ep_port_num;
+		rn = mcapi_db->requests[id].ep_node_num;
+	}
+	if (size)
+		*size = mcapi_db->requests[id].size;
+	if (mcapi_db->requests[id].completed == MCAPI_TRUE) {
+		mcapi_dprintf(1,"%s request (type:%d) has already completed! \n",
+							   __func__, mcapi_db->requests[id].type);
+		*mcapi_status = MCAPI_SUCCESS;
+		mcapi_trans_remove_request(id);
+		return MCAPI_TRUE;
+	}
+	rc = sm_wait_nonblocking(index, re, rn, mcapi_db->requests[id].buffer,
+			size, mcapi_db->requests[id].type, mcapi_db->requests[id].payload, timeout, 1);
+	if (rc) {
+		if (errno == ETIMEDOUT)
+			*mcapi_status = MCAPI_TIMEOUT;
+		else
+			*mcapi_status = MCAPI_ERR_GENERAL;
+		mcapi_db->requests[id].completed == MCAPI_FALSE;
+		mcapi_trans_remove_request(id);
+		return MCAPI_FALSE;
+	} else {
+		if (mcapi_db->requests[id].type == GET_ENDPT) {
+			if (mcapi_trans_get_endpoint_internal(
+						(mcapi_endpoint_t *)mcapi_db->requests[id].buffer,
+						mcapi_db->requests[id].ep_node_num,
+						mcapi_db->requests[id].ep_port_num)) {
+				mcapi_db->requests[id].completed == MCAPI_TRUE;
+				*mcapi_status = MCAPI_SUCCESS;
+				rc = MCAPI_TRUE;
+			} else {
+				mcapi_db->requests[id].completed == MCAPI_FALSE;
+				*mcapi_status = MCAPI_ERR_PARAMETER;
+				rc = MCAPI_FALSE;
+			}
+		} else {
+			mcapi_db->requests[id].completed == MCAPI_TRUE;
+			*mcapi_status = MCAPI_SUCCESS;
+			if (size)
+				mcapi_db->requests[id].size = *size;
+			rc = MCAPI_TRUE;
+		}
+		mcapi_trans_remove_request(id);
+		return rc;
+	}
 }
 
 mcapi_boolean_t mcapi_trans_wait_any( mcapi_request_t* request, size_t* size,mcapi_status_t* mcapi_status)
diff --git a/trans_impl/tran_impl_dev.c b/trans_impl/tran_impl_dev.c
index db014ad..fe8463e 100644
--- a/trans_impl/tran_impl_dev.c
+++ b/trans_impl/tran_impl_dev.c
@@ -90,48 +90,68 @@ int sm_close_session(uint32_t session_idx)
 	return ret;
 }
 
-int sm_send_packet(uint32_t session_idx, uint32_t dst_ep,
-		uint32_t dst_cpu, void *buf, uint32_t len)
+int sm_send_packet(uint32_t session_idx, uint32_t dst_ep, uint32_t dst_cpu,
+		void *buf, uint32_t len, uint32_t *payload, int blocking)
 {
 	int ret;
+	int flags;
 	memset(&pkt, 0, sizeof(pkt));
 	pkt.session_idx = session_idx;
 	pkt.remote_ep = dst_ep;
 	pkt.dst_cpu = dst_cpu;
 	pkt.buf_len = len;
 	pkt.buf = buf;
+	if (flags = fcntl(fd, F_GETFL, 0) > 0) {
+		if (blocking)
+			flags &= ~O_NONBLOCK;
+		else
+			flags |= O_NONBLOCK;
+		fcntl(fd, F_SETFL, flags);
+	}
 	ret = ioctl(fd, CMD_SM_SEND, &pkt);
+	if (payload)
+		*payload = pkt.payload;
 	return ret;
 }
 
-int sm_recv_packet(uint32_t session_idx, uint16_t *dst_ep, uint16_t *dst_cpu, void *buf,
-		uint32_t *len)
+int sm_recv_packet(uint32_t session_idx, uint16_t *dst_ep, uint16_t *dst_cpu,
+		void *buf, uint32_t *len, int blocking)
 {
-	int ret;
+	int ret = 0;
+	int flags;
 	memset(&pkt, 0, sizeof(pkt));
-	printf("session_idx %d\n", session_idx);
 	pkt.session_idx = session_idx;
 	if (buf)
 		pkt.buf = buf;
 	else
 		return -EINVAL;
-	pkt.buf_len = len;
-	ret = ioctl(fd, CMD_SM_RECV, &pkt);
-	if (ret)
-		return ret;
-	if (dst_ep)
-		*dst_ep = pkt.remote_ep;
-	if (dst_cpu)
-		*dst_cpu = pkt.dst_cpu;
 	if (len)
-		*len = pkt.buf_len;
-	return 0;
+		pkt.buf_len = *len;
+
+	if (flags = fcntl(fd, F_GETFL, 0) > 0) {
+		if (blocking)
+			flags &= ~O_NONBLOCK;
+		else
+			flags |= O_NONBLOCK;
+		fcntl(fd, F_SETFL, flags);
+	}
+	ret = ioctl(fd, CMD_SM_RECV, &pkt);
+	if (!ret) {
+		if (dst_ep)
+			*dst_ep = pkt.remote_ep;
+		if (dst_cpu)
+			*dst_cpu = pkt.dst_cpu;
+		if (len)
+			*len = pkt.buf_len;
+	}
+	return ret;
 }
 
-int sm_send_scalar(uint32_t session_idx, uint16_t dst_ep,
-		uint16_t dst_cpu, uint32_t scalar0, uint32_t scalar1, uint32_t size)
+int sm_send_scalar(uint32_t session_idx, uint16_t dst_ep, uint16_t dst_cpu,
+		uint32_t scalar0, uint32_t scalar1, uint32_t size, int blocking)
 {
 	int ret;
+	int flags;
 	memset(&pkt, 0, sizeof(pkt));
 	pkt.session_idx = session_idx;
 	pkt.remote_ep = dst_ep;
@@ -153,20 +173,32 @@ int sm_send_scalar(uint32_t session_idx, uint16_t dst_ep,
 		pkt.type = SM_SESSION_SCALAR_READY_64;
 		break;
 	}
-
-	printf("%s size %d type %x \n", __func__, size, pkt.type);
+	if (flags = fcntl(fd, F_GETFL, 0) > 0) {
+		if (blocking)
+			flags &= ~O_NONBLOCK;
+		else
+			flags |= O_NONBLOCK;
+		fcntl(fd, F_SETFL, flags);
+	}
 	ret = ioctl(fd, CMD_SM_SEND, &pkt);
 	return ret;
 }
 
-int sm_recv_scalar(uint32_t session_idx, uint16_t *src_ep, uint16_t *src_cpu, uint32_t *scalar0,
-		uint32_t *scalar1, uint32_t *size)
+int sm_recv_scalar(uint32_t session_idx, uint16_t *src_ep, uint16_t *src_cpu,
+		uint32_t *scalar0, uint32_t *scalar1, uint32_t *size, int blocking)
 {
 	int ret = 0;
+	int flags;
 	memset(&pkt, 0, sizeof(pkt));
 	pkt.session_idx = session_idx;
 	pkt.type = SM_SESSION_SCALAR_READY_64;
-
+	if (flags = fcntl(fd, F_GETFL, 0) > 0) {
+		if (blocking)
+			flags &= ~O_NONBLOCK;
+		else
+			flags |= O_NONBLOCK;
+		fcntl(fd, F_SETFL, flags);
+	}
 	ret = ioctl(fd, CMD_SM_RECV, &pkt);
 	if (ret)
 		return ret;
@@ -180,10 +212,28 @@ int sm_recv_scalar(uint32_t session_idx, uint16_t *src_ep, uint16_t *src_cpu, ui
 		*scalar1 = pkt.buf_len;
 	if (size)
 		*size = pkt.type;
-
 	return 1;
 }
 
+int sm_get_remote_ep(uint32_t dst_ep, uint32_t dst_cpu, int timeout, int blocking)
+{
+	int ret;
+	int flags;
+	memset(&pkt, 0, sizeof(pkt));
+	pkt.remote_ep = dst_ep;
+	pkt.dst_cpu = dst_cpu;
+	pkt.timeout = timeout;
+	if (flags = fcntl(fd, F_GETFL, 0) > 0) {
+		if (blocking)
+			flags &= ~O_NONBLOCK;
+		else
+			flags |= O_NONBLOCK;
+		fcntl(fd, F_SETFL, flags);
+	}
+	ret = ioctl(fd, CMD_SM_QUERY_REMOTE_EP, &pkt);
+	return ret;
+}
+
 int sm_get_session_status(uint32_t session_idx, struct sm_session_status *status)
 {
 	int ret;
@@ -195,10 +245,36 @@ int sm_get_session_status(uint32_t session_idx, struct sm_session_status *status
 	pkt.param = status;
 	pkt.param_len = sizeof(*status);
 	ret = ioctl(fd, CMD_SM_GET_SESSION_STATUS, &pkt);
-
 	return ret;
 }
 
+int sm_wait_nonblocking(uint32_t session_idx, uint32_t dst_ep, uint32_t dst_cpu,
+	void *buf, uint32_t *len, uint32_t type, uint32_t payload, unsigned int timeout, int blocking)
+{
+	int ret;
+	int flags;
+	memset(&pkt, 0, sizeof(pkt));
+	pkt.session_idx = session_idx;
+	pkt.remote_ep = dst_ep;
+	pkt.dst_cpu = dst_cpu;
+	pkt.buf = buf;
+	pkt.type = type;
+	pkt.timeout = timeout;
+	pkt.payload = payload;
+	if (len)
+		pkt.buf_len = *len;
+	if (flags = fcntl(fd, F_GETFL, 0) > 0) {
+		if (blocking)
+			flags &= ~O_NONBLOCK;
+		else
+			flags |= O_NONBLOCK;
+		fcntl(fd, F_SETFL, flags);
+	}
+	ret = ioctl(fd, CMD_SM_WAIT, &pkt);
+	if (len)
+		*len = pkt.buf_len;
+	return ret;
+}
 
 int sm_get_node_status(uint32_t node, uint32_t *session_mask, uint32_t *session_pending, uint32_t *nfree)
 {
-- 
2.11.0

